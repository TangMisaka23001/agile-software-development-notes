# 第二部分 敏捷设计

拙劣设计的症状：

- 僵化性： 设计难以改变
  - 很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的其他改动。
- 脆弱性： 设计易于遭到破坏
  - 对系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题。
- 牢固性： 设计难以重用
  - 很难解开系统的纠结，使之成为一些可在其他系统中重用的组件。
- 粘滞性： 难以做正确的事情
  - 做正确的事情比做错误的事情要困难。
- 不必要的复杂性： 过分设计
  - 设计中包含有不具任何好处的基础结构。
- 不必要的重复： 滥用鼠标
  - 设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统一。
- 晦涩性： 混乱的表达
  - 很难阅读、理解。没有很好地表现出意图。

面向对象设计原则：

- 单一职责原则 SRP
- 开放-封闭原则 OCP
- Liskov替换原则 LSP
- 依赖倒置原则 DIP
- 接口隔离原则 ISP

因此，简而言之，敏捷人员知道要做什么，是因为：

1. 他们遵循敏捷实践去发现问题。
2. 他们应用设计原则去诊断问题；并且
3. 他们应用适当的设计模式去解决问题。

软件开发的这三个方面间的相互作用就是设计。

### 7.4 尽可能保持好的设计

敏捷开发人员致力于保持设计尽可能地适当、干净。这不是一个随便的或者暂时性的承诺。敏捷开发人员不是每几周才清洁他们的设计。而是每天、每小
时、 甚至每分钟都要保持软件尽可能地干净、简单并富有表现力。他们从不说，“稍后我会回来修正它。”他们决不让腐化出现。

### 7.5 结论

那么，什么是敏捷设计呢？敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于
保持系统设计在任何时间都尽可能得简单、干净以及富有表现力。

## 第八章 单一职责原则（SRP）

> 就一个类而言，应该仅有一个引起它变化的原因。

如果一个类承担的职责过多，就等于把这些责任耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的
设计，当变化发生时，设计会遭到意想不到的破坏。

在SRP中，我们把指责定义为“变化的原因”。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多余一个的职责。有时，我们很难注意到
这一点。我们习惯于以组的形式去考虑职责。

在此还有一个推论。变化的轴线仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者任何其他的原则都是不明智的。

## 第九章 开放 -- 封闭原则（OCP）

> 软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。

如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。

遵循开放 -- 封闭原则设计出的模块具有两个主要的特征。它们是：

1. 对于扩展是开放的  
   这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块
   的功能。
2. 对于更改是封闭的
   对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者Java的.jar文件，都无需改动

一般而言，无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。没有对于所有情况都贴切的模型。

既然不可能完全封闭，那么就必须有策略地对待这个问题。也就是说，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出
最有可能发生变化的种类，然后构造抽象来隔离那些变化。

OCP背后的主要机制是抽象和多态。支持抽象和多态的关键机制之一是继承。正是使用了继承，我们才可以创建实现其基类中抽象方法的派生类。

是什么设计规则在支配着这种特殊的继承用法呢？
最佳的继承层次的特征又是什么呢？
怎样的情况会使我们创建的类层次结构掉进不符合OCP的陷阱中去呢？
这些正是Liskov替换原则要解答的问题。

## 第十章 Liskov替换原则（LSP）

> 子类型必须能够替换掉它们的基类型。

OCP是OOD中很多说法的核心。如果这个原则应用得有效，应用程序就会具有更多的可维护性、可重用性以及健壮性。LSP是使OCP成为可能的主要原则之一。
正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展。这种可替换性必须是开发人员可以隐式依赖的东西。因此，如果没有
显式地强制基类类型的契约，那么代码就必须良好地并明显地表达出这一点。

## 第十一章 依赖倒置原则（DIP）

> - 高层模块不应该依赖于低层模块。二者都应该依赖于抽象。
> - 抽象不应该依赖于细节。细节应该依赖于抽象。

一个稍微简单但仍然非常有效的对于DIP的解释，是这样一个简单的启发式规则：“依赖于抽象。”这是一个简单的陈述，该启发规则建议不应该依赖于具体
类————也就是说，程序中所有的依赖关系都应该终止于抽象类或者接口。

根据这个启发式规则，可知：

- 任何变量都不应该持有一个指向具体类的指针或者引用
- 任何类都不应该从具体类派生
- 任何方法都不应该覆写它的任何基类中的已经实现了的方法

## 第十二章 接口隔离原则（ISP）

> 不应该强迫客户依赖于它们不用的方法。

这个原则用来处理“胖”接口所具有的缺点。如果类的接口不是内聚的，就表示该类具有“胖”的接口。换句话说，类的“胖”接口可以分解成多组方法。每一组
方法都服务与一组不同的客户程序。

ISP承认存在有一些对象，它们确实不需要内聚的接口；但是ISP建议客户程序不应该看到它们作为单一的类存在。相反，客户程序看到的应该是多个具有
内聚接口的抽象类。

