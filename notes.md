# 第三部分 薪水支付案例研究

## 第十三章 COMMAND模式和ACTIVE OBJECT模式

事实上，该模式横过了一条非常有趣的界线。而这个交界处正是所有有趣的复杂性之所在。大多数类都是一组方法和相应的一组变量的结合。COMMAND模式
不是这样的。它只是封装了一个没有任何变量的函数。

另一个COMMAND模式的常见用法是创建和执行事务操作。

### UNDO

如果command派生类的do()方法可以记住它所执行的操作的细节，那么undo方法就可以取消这些操作，并把系统恢复到原先的状态。

## 第十四章 template method模式和 strategy模式：继承与委托

像大多数美丽新世界一样，它最终也被证明有些不切实际。知道1995年，人们才清楚地认识到继承非常容易被过度使用，而且过度使用的代价是非常高的。
所以我们减少了对继承的使用，常常使用组合或者委托来代替它。

template method模式和 strategy模式都可以用来分离高层的算法和低层的具体实现细节。都允许高层的算法独立于它的具体实现细节重用。此外，
strategy模式也允许具体实现细节独立于高层的算法重用，不过要以一些额外的复杂性、内存 以及运行时间开销作为代价。

## 第十五章 facade模式和mediator模式

本章中论述的两个模式有着共同的目的。它们都把某种策略施加到另外一组对象上。facade模式从上面施加策略，而mediator模式则从下面施加策略。
facade模式的使用是明显且受限的，而mediator模式的使用则是不明显且不受限制的。

## 第十六章 singleton模式和monostate模式

### singleton模式的好处

- 跨平台：可以跨多个JVM和多个计算机工作
- 适用于任何类：只需把一个类的构造函数变成私有的，并且在其中增加相应的静态函数和变量，就可以把这个类变为singleton
- 可以透过派生创建：给定一个类，可以创建它的一个singleton子类
- 延迟求值：如果singleton从未使用过，那么就决不会创建它。

### singleton模式的代价

- 摧毁方法未定义：没有好的方法去摧毁一个singleton，或者解除其职责
- 不能继承：从singleton类派生出来的类并不是singleton。
- 效率问题：每次调用instance方法都会执行if语句。就大多数调用而言，if语句是多余的。
- 不透明性：singleton的使用者知道它们正在使用一个singleton，因为他们必须要调用instance方法。

### monostate模式的好处

- 透明性：使用monostate对象和使用常规对象没有什么区别。使用者不需要知道对象是monostate
- 可派生性：monostate的派生类都是monostate。
- 多态性：由于monostate的方法不是静态的，所以可以在派生类中覆写它们。

### monostate模式的代价

- 不可转换性：不能透过派生把常规类转换成monostate类
- 效率问题：因为monostate是真正的对象，所以会导致许多的创建和摧毁开销。
- 内存占用：即使从未使用monostate，它的变量也要占据内存空间。
- 平台局限性：monostate不能跨多个JVM或者多个平台工作。

如果希望透过派生去约束一个现存类，并且不介意它的所有调用者都必须要调用instance()方法来获取访问权，那么singleton是最合适的。如果希望
类的单一性本质对使用者透明，或者希望使用单一对象的多态派生对象，那么monostate是最合适的。

## 第十七章 null object模式

可以使用null object模式来解决这些问题。通常，该模式会消除对null进行检查的需要，并且有助于简化代码。

那些长期使用C-based语言的人已经习惯于函数对某种失败返回null或者0。我们认为对这样的函数的返回值是需要检查的。null
object模式改变了这一
点。使用该模式，我们可以确保函数总是返回有效的对象，即使在它们失败时也是如此。这些代表失败的对象“什么也不做”。

